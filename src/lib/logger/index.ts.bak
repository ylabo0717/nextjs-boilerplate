/**
 * 構造化ログシステム統合エクスポート
 * Client/Server双方対応の統一インターフェース
 */

// 型定義とインターフェース
export type {
  Logger,
  LogLevel,
  LogArgument,
  LoggerContext,
  BaseProperties,
  SanitizedLogEntry,
} from './types';

// コア機能
export {
  sanitizeLogEntry,
  sanitizeControlCharacters,
  sanitizeForJson,
  limitObjectSize,
} from './sanitizer';

export { hashIP, validateIPHashSecret } from './crypto';

export {
  getLogLevelFromEnv,
  getClientLogLevel,
  createBaseProperties,
  generateRequestId,
  serializeError,
  isLogLevelEnabled,
  getLogLevelValue,
  REDACT_PATHS,
} from './utils';

// コンテキスト管理
export {
  runWithLoggerContext,
  getLoggerContext,
  createContextualLogger,
  loggerContextManager,
} from './context';

// サーバーサイドLogger
export { serverLogger, serverLoggerWrapper, serverLoggerHelpers } from './server';

// クライアントサイドLogger
export { clientLogger, clientLoggerWrapper, clientLoggerHelpers } from './client';

// Middleware統合
export {
  createRequestContext,
  logRequestStart,
  logRequestEnd,
  logSecurityEvent,
  logMiddlewareError,
  logRateLimit,
  logRedirect,
  middlewareLoggerHelpers,
} from './middleware';

// エラーハンドリング
export { ErrorClassifier, ErrorHandler, errorHandlerUtils } from './error-handler';

export type { ErrorCategory, ErrorContext, StructuredError } from './error-handler';

/**
 * 環境自動判定Logger
 * サーバー/クライアント環境を自動判定して適切なLoggerを返す
 */
export const logger = (() => {
  // サーバーサイド判定
  if (typeof window === 'undefined') {
    // Node.js環境
    try {
      // eslint-disable-next-line @typescript-eslint/no-require-imports
      const { serverLoggerWrapper } = require('./server');
      return serverLoggerWrapper;
    } catch {
      // Edge Runtime等でPinoが使用できない場合のフォールバック
      // eslint-disable-next-line @typescript-eslint/no-require-imports
      const { clientLoggerWrapper } = require('./client');
      return clientLoggerWrapper;
    }
  } else {
    // ブラウザ環境
    // eslint-disable-next-line @typescript-eslint/no-require-imports
    const { clientLoggerWrapper } = require('./client');
    return clientLoggerWrapper;
  }
})();

/**
 * 統合Logger初期化関数
 * アプリケーション起動時に呼び出す
 */
export function initializeLogger(
  options: {
    enableGlobalErrorHandlers?: boolean;
    context?: Record<string, unknown>;
  } = {}
): void {
  const { enableGlobalErrorHandlers = true, context = {} } = options;

  // グローバルエラーハンドラーの設定
  if (enableGlobalErrorHandlers) {
    setupGlobalErrorHandlers();
  }

  // 初期コンテキストの設定
  if (Object.keys(context).length > 0) {
    // Note: これはサーバーサイドでのみ有効
    if (typeof window === 'undefined') {
      // eslint-disable-next-line @typescript-eslint/no-require-imports
      const { loggerContextManager } = require('./context');
      loggerContextManager.runWithContext(context, () => {
        logger.info('Logger initialized with context', context);
      });
    } else {
      logger.info('Logger initialized', context);
    }
  } else {
    logger.info('Logger initialized');
  }
}

/**
 * グローバルエラーハンドラーの設定
 */
function setupGlobalErrorHandlers(): void {
  // eslint-disable-next-line @typescript-eslint/no-require-imports
  const { ErrorHandler } = require('./error-handler');
  const errorHandler = new ErrorHandler(logger);

  if (typeof window === 'undefined') {
    // Node.js環境
    process.on('uncaughtException', (error: Error) => {
      errorHandler.handleUncaughtException(error, {
        timestamp: new Date().toISOString(),
      });

      // アプリケーションを適切に終了
      process.exit(1);
    });

    process.on('unhandledRejection', (reason: unknown) => {
      errorHandler.handleUnhandledRejection(reason, {
        timestamp: new Date().toISOString(),
      });
    });
  } else {
    // ブラウザ環境
    window.addEventListener('error', (event) => {
      errorHandler.handle(event.error, {
        path: window.location.pathname,
        userAgent: navigator.userAgent,
        timestamp: new Date().toISOString(),
        additionalData: {
          filename: event.filename,
          lineno: event.lineno,
          colno: event.colno,
        },
      });
    });

    window.addEventListener('unhandledrejection', (event) => {
      errorHandler.handleUnhandledRejection(event.reason, {
        path: window.location.pathname,
        userAgent: navigator.userAgent,
        timestamp: new Date().toISOString(),
      });
    });
  }
}

/**
 * コンテキスト付きLogger取得
 */
export function getLoggerWithContext(context: Record<string, unknown>): any {
  if (typeof window === 'undefined') {
    // サーバーサイド
    const { createContextualLogger } = require('./context');
    return createContextualLogger(logger, context);
  } else {
    // クライアントサイド（コンテキストは個別に付与）
    return {
      trace: (message: string, ...args: any[]) => logger.trace(message, context, ...args),
      debug: (message: string, ...args: any[]) => logger.debug(message, context, ...args),
      info: (message: string, ...args: any[]) => logger.info(message, context, ...args),
      warn: (message: string, ...args: any[]) => logger.warn(message, context, ...args),
      error: (message: string, ...args: any[]) => logger.error(message, context, ...args),
      fatal: (message: string, ...args: any[]) => logger.fatal(message, context, ...args),
      isLevelEnabled: (level: string) => logger.isLevelEnabled(level as any),
    };
  }
}

/**
 * 統合パフォーマンス測定
 */
export function measurePerformance<T>(
  name: string,
  fn: () => T,
  context: Record<string, unknown> = {}
): T {
  if (typeof window === 'undefined') {
    // サーバーサイド
    const { serverLoggerHelpers } = require('./server');
    return serverLoggerHelpers.measurePerformance(name, fn);
  } else {
    // クライアントサイド
    const { clientLoggerHelpers } = require('./client');
    return clientLoggerHelpers.measurePerformance(name, fn);
  }
}

/**
 * 統合非同期パフォーマンス測定
 */
export async function measurePerformanceAsync<T>(
  name: string,
  fn: () => Promise<T>,
  context: Record<string, unknown> = {}
): Promise<T> {
  if (typeof window === 'undefined') {
    // サーバーサイド
    const { serverLoggerHelpers } = require('./server');
    return serverLoggerHelpers.measurePerformanceAsync(name, fn);
  } else {
    // クライアントサイド - 同期版を使用
    const { clientLoggerHelpers } = require('./client');
    return clientLoggerHelpers.measurePerformance(name, () => fn()) as Promise<T>;
  }
}

/**
 * 統合ユーザーアクションログ
 */
export function logUserAction(action: string, details: Record<string, unknown> = {}): void {
  if (typeof window === 'undefined') {
    // サーバーサイド
    const { serverLoggerHelpers } = require('./server');
    serverLoggerHelpers.logUserAction(action, details);
  } else {
    // クライアントサイド
    const { clientLoggerHelpers } = require('./client');
    clientLoggerHelpers.logUserAction(action, details);
  }
}

/**
 * 統合エラーログ
 */
export function logError(error: Error | unknown, context: Record<string, unknown> = {}): void {
  if (typeof window === 'undefined') {
    // サーバーサイド
    const { ErrorHandler } = require('./error-handler');
    const errorHandler = new ErrorHandler(logger);
    errorHandler.handle(error, context);
  } else {
    // クライアントサイド
    const { clientLoggerHelpers } = require('./client');
    clientLoggerHelpers.logError(error, context);
  }
}

/**
 * デバッグ用Logger情報表示
 */
export function debugLogger(): void {
  const info = {
    environment: typeof window === 'undefined' ? 'server' : 'client',
    logLevel:
      typeof window === 'undefined'
        ? process.env.LOG_LEVEL || 'info'
        : process.env.NEXT_PUBLIC_LOG_LEVEL || 'info',
    nodeEnv: process.env.NODE_ENV,
    runtime: typeof window === 'undefined' ? process.env.NEXT_RUNTIME || 'nodejs' : 'browser',
    timestamp: new Date().toISOString(),
  };

  logger.debug('Logger debug information', info);
}

// デフォルトエクスポート
export default logger;
